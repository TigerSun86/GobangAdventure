using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class MoveAlongPath : MonoBehaviour
{
    public List<Vector2> path;

    public float speed = 1f;

    public int curveResolution = 10;

    [SerializeField] UnityEvent reachedEndEvent;

    private int currentIndex = 0;

    private float distanceToNextPoint = 0.0f;

    public void SetPath(List<Vector2> path, bool isCurve = false)
    {
        if (path.Count == 0)
        {
            throw new ArgumentException("Path cannot be empty", nameof(path));
        }

        transform.position = path[0];
        if (path.Count == 1)
        {
            this.path = path;
            reachedEndEvent.Invoke();
            return;
        }

        if (isCurve)
        {
            this.path = CurveUtility.GenerateCurvePath(path, curveResolution);
        }
        else
        {
            this.path = path;
        }

        distanceToNextPoint = CalculateDistanceToNextPoint();
    }

    private void Update()
    {
        transform.position = (Vector2)CalculateNextPosition(transform.position);
    }

    // The first version is generated by ChatGPT.
    private Vector2 CalculateNextPosition(Vector2 currentPoint)
    {
        if (currentIndex >= path.Count - 1)
        {
            return currentPoint;
        }

        Vector2 nextPoint = path[currentIndex + 1];
        Vector2 direction = (nextPoint - currentPoint).normalized;
        float distance = speed * Time.deltaTime;

        // Update the remaining distance to the next point
        distanceToNextPoint -= distance;

        // If the object has reached the next point, move to the next segment
        if (distanceToNextPoint <= 0.0f)
        {
            currentIndex++;
            distanceToNextPoint = CalculateDistanceToNextPoint();
        }

        // Move the object along the current segment
        return currentPoint + (direction * distance);
    }

    private float CalculateDistanceToNextPoint()
    {
        if (currentIndex >= path.Count - 1)
        {
            reachedEndEvent.Invoke();
            return 0;
        }

        Vector2 currentPoint = path[currentIndex];
        Vector2 nextPoint = path[currentIndex + 1];
        return Vector2.Distance(currentPoint, nextPoint);
    }

    private void OnDrawGizmos()
    {
        if (path == null)
        {
            return;
        }

        foreach (Vector2 p in path)
        {
            Gizmos.DrawSphere(p, 0.2f);
        }
    }
}
