using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public static class CurveUtility
{
    public static List<Vector2> GenerateCurvePath(List<Vector2> points, float curveResolution)
    {
        if (points.Count > 3)
        {
            Debug.LogError($"{points.Count} points haven't been suppported");
        }

        Vector2 c1 = points[0];
        Vector2 c2 = points[1];
        Vector2 c3 = points[2];
        (Vector2 ep, Vector2 fp) = GenerateControlPoints(c1, c2, c3);

        List<Vector2> path = new List<Vector2>();
        path.AddRange(GenerateBezierPath(c1, c2, ep, curveResolution));

        // Remove the duplicated c2.
        path.RemoveAt(path.Count - 1);
        path.AddRange(GenerateBezierPath(c2, c3, fp, curveResolution));
        return path;
    }

    // https://upload-images.jianshu.io/upload_images/2114436-af403f13333d5770.png?imageMogr2/auto-orient/strip|imageView2/2/w/566/format/webp
    // 如上图所示：如果需要绘制一条通过点A、B、C的曲线，我们需要计算各条用于连接的贝塞尔曲线的控制点。
    // 以顶点B为例：
    // 1、取AB和BC的中点E、F，并连接E、F
    // 2、在EF上取点D，使得FD/DE = BC/AB
    // 3、将直线EF按照矢量DB平移到通过B点，并且使得平移后的D和B点重合
    // 4、得到E'与F'点用作贝塞尔曲线的控制点。
    // 将上述算法应用于多边形的各个顶点，可以计算出2*n个控制点（每个顶点对应两个控制点）
    // 作者：狂风无迹
    // 链接：https://www.jianshu.com/p/55099e3a2899
    // 来源：简书
    // 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
    private static (Vector2 controlPoint1, Vector2 controlPoint2) GenerateControlPoints(Vector2 startPoint, Vector2 midPoint, Vector2 endPoint)
    {
        Vector2 a = startPoint;
        Vector2 b = midPoint;
        Vector2 c = endPoint;
        Vector2 e = (a + b) / 2;
        Vector2 f = (b + c) / 2;
        Vector2 ef = f - e;
        float efMag = ef.magnitude;
        float abMag = Vector2.Distance(a, b);
        float bcMag = Vector2.Distance(b, c);
        float edMag = (abMag * efMag) / (abMag + bcMag);
        Vector2 ed = ef * edMag / efMag;
        Vector2 ep = b - ed;
        Vector2 df = ef - ed;
        Vector2 fp = b + df;
        return (ep, fp);
    }

    // The first version is generated by ChatGPT.
    private static List<Vector2> GenerateBezierPath(Vector2 startPoint, Vector2 endPoint, Vector2 controlPoint, float curveResolution)
    {
        List<Vector2> result = new List<Vector2>();
        for (int i = 0; i <= curveResolution; i++)
        {
            float t = (float)i / curveResolution;
            Vector2 point = CalculateBezierPoint(t, startPoint, endPoint, controlPoint);
            result.Add(point);
        }

        return result;
    }

    // The first version is generated by ChatGPT.
    private static Vector2 CalculateBezierPoint(float t, Vector2 startPoint, Vector2 endPoint, Vector2 controlPoint)
    {
        Vector2 p0 = startPoint;
        Vector2 p2 = endPoint;
        Vector2 p1 = controlPoint;
        float u = 1 - t;
        float tt = t * t;
        float uu = u * u;

        Vector2 p = uu * p0;
        p += 2 * u * t * p1;
        p += tt * p2;

        return p;
    }
}
